/*
 * This Java source file was generated by the Gradle 'init' task.
 */
/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package minijar;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.zip.ZipEntry;

//import com.ibm.wala.util.config.AnalysisScopeReader;
import com.ibm.wala.core.util.config.AnalysisScopeReader;
import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.classLoader.Language;
import com.ibm.wala.core.java11.Java9AnalysisScopeReader;
import com.ibm.wala.core.util.warnings.Warnings;
import com.ibm.wala.ipa.callgraph.AnalysisCache;
import com.ibm.wala.ipa.callgraph.AnalysisCacheImpl;
import com.ibm.wala.ipa.callgraph.AnalysisOptions;
import com.ibm.wala.ipa.callgraph.AnalysisScope;
import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.CallGraphBuilder;
import com.ibm.wala.ipa.callgraph.CallGraphBuilderCancelException;
import com.ibm.wala.ipa.callgraph.Entrypoint;
import com.ibm.wala.ipa.callgraph.impl.Util;
import com.ibm.wala.ipa.callgraph.propagation.InstanceKey;
import com.ibm.wala.ipa.cha.ClassHierarchyException;
import com.ibm.wala.ipa.cha.ClassHierarchyFactory;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ipa.slicer.SDG;
import com.ibm.wala.ipa.slicer.Slicer.ControlDependenceOptions;
import com.ibm.wala.ipa.slicer.Slicer.DataDependenceOptions;
//import com.ibm.wala.shrike.shrikeCT.ClassWriter.CWStringItem;
import com.ibm.wala.shrikeBT.Decoder.InvalidBytecodeException;
import com.ibm.wala.shrikeBT.shrikeCT.ClassInstrumenter;
import com.ibm.wala.shrikeBT.shrikeCT.OfflineInstrumenter;
import com.ibm.wala.shrikeCT.ClassConstants;
import com.ibm.wala.shrikeCT.ClassReader;
import com.ibm.wala.shrikeCT.ClassReader.AttrIterator;
import com.ibm.wala.shrikeCT.ClassWriter;
import com.ibm.wala.shrikeCT.ClassWriter.Element;
import com.ibm.wala.shrikeCT.ConstantPoolParser;
import com.ibm.wala.shrikeCT.ConstantPoolParser.ReferenceToken;
import com.ibm.wala.util.collections.HashMapFactory;
import com.ibm.wala.util.config.FileOfClasses;
import com.ibm.wala.shrikeCT.InvalidClassFileException;

public class MiniJar {
  private static final String USAGE =
      "MiniJar usage:\n"
          + "This tool takes the following command line options:\n"
          + "    <jarname> <jarname> ...   Process the classes from these jars\n"
          + "    -o <jarname>              Put the resulting classes into <jarname>\n";

  private static OfflineInstrumenter instrumenter;


  static class UnknownAttributeException extends Exception {
    private static final long serialVersionUID = 8845177787110364793L;

    UnknownAttributeException(String t) {
      super("Attribute '" + t + "' not understood");
    }
  }

  public static void main(String[] args) throws Exception {
    if (args == null || args.length == 0) {
      System.err.println(USAGE);
      System.exit(1);
    }

    String jarFile = "";
    String mainClass = "";
    String scopeFileData = "";
    for (int i = 0; i < args.length - 1; i++) {
      if (args[i] == null) {
        throw new IllegalArgumentException("args[" + i + "] is null");
      }
      if (!args[i].startsWith("-")) {
          jarFile = args[i];  // Assuming a single jar is passed in
      }
      if (args[i].startsWith("-m")) {
    	  mainClass = args[i+1];
      }
      if (args[i].startsWith("-d")) {
    	  scopeFileData = args[i+1];
      }
    }
    
    if (jarFile == "") {
    	throw new IllegalArgumentException("No Jar file specified");
    }
    
    
    final ArrayList<ZipEntry> entries = new ArrayList<>();

    instrumenter = new OfflineInstrumenter();
    instrumenter.setManifestBuilder(entries::add);
    instrumenter.parseStandardArgs(args);
    instrumenter.beginTraversal();
    ClassInstrumenter ci;
    MiniJar cw = new MiniJar();
    Set<String> cg = cw.getReachableMethods(jarFile, mainClass, scopeFileData);
   
    while ((ci = instrumenter.nextClass()) != null) {
      try {
        cw.doClass(ci, cg);
      } catch (UnknownAttributeException ex) {
        System.err.println(ex.getMessage() + " in " + instrumenter.getLastClassResourceName());
      }
    }

    instrumenter.writeUnmodifiedClasses();
    instrumenter.close();
  }

//  private Set<CGNode> getNodes(CallGraph cg) {
//	  Set<CGNode> ret = new HashSet<CGNode>();
//	  cg.forEach(n -> ret.add(n));  
//	  return ret;
//  }
//  private Element transformAttribute(ClassReader cr, int m, ClassWriter w, AttrIterator iter)
//      throws InvalidClassFileException, UnknownAttributeException, InvalidBytecodeException {
//	  
//	  int offset = iter.getRawOffset();
//	  int end = offset + iter.getRawSize();
//      return new ClassWriter.RawElement(cr.getBytes(), offset, end - offset);
//  }
//
//  private Element[] collectAttributes(ClassReader cr, int m, ClassWriter w, AttrIterator iter)
//      throws InvalidClassFileException, UnknownAttributeException, InvalidBytecodeException {
//    Element[] elems = new Element[iter.getRemainingAttributesCount()];
//    for (int i = 0; i < elems.length; i++) {
//      elems[i] = transformAttribute(cr, m, w, iter);
//      iter.advance();
//    }
//    return elems;
//  }

//  private static int copyEntry(ConstantPoolParser cp, ClassWriter w, int i)
//      throws InvalidClassFileException {
//    byte t = cp.getItemType(i);
//    switch (t) {
//      case ClassConstants.CONSTANT_String:
//        return w.addCPString(cp.getCPString(i));
//      case ClassConstants.CONSTANT_Class:
//        return w.addCPClass(cp.getCPClass(i));
//      case ClassConstants.CONSTANT_FieldRef:
//        return w.addCPFieldRef(cp.getCPRefClass(i), cp.getCPRefName(i), cp.getCPRefType(i));
//      case ClassConstants.CONSTANT_InterfaceMethodRef:
//        return w.addCPInterfaceMethodRef(
//            cp.getCPRefClass(i), cp.getCPRefName(i), cp.getCPRefType(i));
//      case ClassConstants.CONSTANT_MethodRef:
//        return w.addCPMethodRef(cp.getCPRefClass(i), cp.getCPRefName(i), cp.getCPRefType(i));
//      case ClassConstants.CONSTANT_NameAndType:
//        return w.addCPNAT(cp.getCPNATName(i), cp.getCPNATType(i));
//      case ClassConstants.CONSTANT_Integer:
//        return w.addCPInt(cp.getCPInt(i));
//      case ClassConstants.CONSTANT_Float:
//        return w.addCPFloat(cp.getCPFloat(i));
//      case ClassConstants.CONSTANT_Long:
//        return w.addCPLong(cp.getCPLong(i));
//      case ClassConstants.CONSTANT_Double:
//        return w.addCPDouble(cp.getCPDouble(i));
//      case ClassConstants.CONSTANT_Utf8:
//        return w.addCPUtf8(cp.getCPUtf8(i));
//      case ClassConstants.CONSTANT_InvokeDynamic:
//    	return w.addCPInvokeDynamic(cp.getCPDynBootstrap(i), cp.getCPDynName(i), cp.getCPDynType(i));
//      case ClassConstants.CONSTANT_MethodHandle:
//    	return w.addCPMethodHandle(new ReferenceToken(cp.getCPHandleKind(i), cp.getCPHandleClass(i), cp.getCPHandleName(i), cp.getCPHandleType(i)));
//      default:
//        return -1;
//        
//    }
//  }

  private void doClass(final ClassInstrumenter ci, Set<String> cg) throws Exception {
    /*
     * Our basic strategy is to make the first element of the constant pool be the copyright string (as a UTF8 constant pool item).
     * This requires us to parse and emit any class data which might refer to that constant pool item (#1). We will assume that any
     * attribute which refers to that constant pool item must contain the byte sequence '00 01', so we can just copy over any
     * attributes which don't contain that byte sequence. If we detect an unknown attribute type containing the sequence '00 01',
     * then we will abort.
     */
    ClassReader cr = ci.getReader();
    
    ClassWriter cw =
            new ClassWriter() {
              private final Map<Object, Integer> entries = HashMapFactory.make();

              {
                ConstantPoolParser p = cr.getCP();
                for (int i = 1; i < p.getItemCount(); i++) {
                  final byte itemType = p.getItemType(i);
                  switch (itemType) {
                    case CONSTANT_Integer:
                      entries.put(p.getCPInt(i), i);
                      break;
                    case CONSTANT_Long:
                      entries.put(p.getCPLong(i), i);
                      break;
                    case CONSTANT_Float:
                      entries.put(p.getCPFloat(i), i);
                      break;
                    case CONSTANT_Double:
                      entries.put(p.getCPDouble(i), i);
                      break;
                    case CONSTANT_Utf8:
                      entries.put(p.getCPUtf8(i), i);
                      break;
                    case CONSTANT_String:
                      entries.put(new CWStringItem(p.getCPString(i), CONSTANT_String), i);
                      break;
                    case CONSTANT_Class:
                      entries.put(new CWStringItem(p.getCPClass(i), CONSTANT_Class), i);
                      break;
                    default:
                      // do nothing
                  }
                }
              }

              private int findExistingEntry(Object o) {
                return entries.getOrDefault(o, -1);
              }

              @Override
              protected int addCPEntry(Object o, int size) {
                int entry = findExistingEntry(o);
                if (entry != -1) {
                  return entry;
                } else {
                  return super.addCPEntry(o, size);
                }
              }
            };
    

//    w.setForceAddCPEntries(true);
//
//    ConstantPoolParser cp = cr.getCP();
//    int CPCount = cp.getItemCount();
    String className = cr.getName();
//    System.out.println("doClass: " + cr.getName());
//
//    for (int i = 1; i < CPCount; i++) {
//      int r = copyEntry(cp, w, i);
//      if (r != -1 && r != i) {
//        System.err.println("Invalid constant pool index allocated: " + r + ", expected " + i);
//      }
//    }
//    w.setForceAddCPEntries(false);


    // emit class
//    w.setMajorVersion(cr.getMajorVersion());
//    w.setMinorVersion(cr.getMinorVersion());
//    w.setAccessFlags(cr.getAccessFlags());
//    w.setName(cr.getName());
//    w.setSuperName(cr.getSuperName());
//    w.setInterfaceNames(cr.getInterfaceNames());
//
    ClassReader.AttrIterator iter = new ClassReader.AttrIterator();
//
//    int fieldCount = cr.getFieldCount();
//    for (int i = 0; i < fieldCount; i++) {
//      cr.initFieldAttributeIterator(i, iter);
//      w.addField(
//          cr.getFieldAccessFlags(i),
//          cr.getFieldName(i),
//          cr.getFieldType(i),
//          collectAttributes(cr, i, w, iter));
//    }

    int methodCount = cr.getMethodCount();
    

    for (int i = 0; i < methodCount; i++) {
      cr.initMethodAttributeIterator(i, iter);
      String methodName = cr.getMethodName(i);
      String methodType = cr.getMethodType(i);

      if (!isReachable(cg, className, methodName, methodType)) {
    	  ci.deleteMethod(i);
      }
      
   
      
      //System.out.println("method: " + methodName + " with type: " + methodType);
//      if (isReachable(cg, className, methodName, methodType)) {
//    	  w.addMethod(
//    			  cr.getMethodAccessFlags(i),
//    			  methodName,
//    			  methodType,
//    			  collectAttributes(cr, i, w, iter));
//      } 
    }

//    cr.initClassAttributeIterator(iter);
//    for (; iter.isValid(); iter.advance()) {
//      w.addClassAttribute(transformAttribute(cr, 0, w, iter));
//    }

    ci.emitClass(cw);
    instrumenter.outputModifiedClass(ci, cw);
    
   
  }

  private static String getMethodString (String className, String methodName, String methodType) {
	  String ret = className + "#" + methodName + methodType;
	  if (className.startsWith("L")) {
		  return ret;
	  }
	  return "L" + ret;
  }
  
  private boolean isReachable(Set<String> cg, String className, String methodName, String methodType) {
	  String desc = getMethodString(className, methodName, methodType);
	  boolean reachable = cg.contains(desc);
	  if (reachable) {
		  System.out.println("Reachable: " + desc);
	  } else {
		  System.out.println("Not reachable: " + desc);
	  }
	  return reachable;
  }
  
  private Set<String> getReachableMethods(String scopeFile, String mainClass, String scopeFileData) throws IOException, ClassHierarchyException, IllegalArgumentException, CallGraphBuilderCancelException {
	
	//AnalysisScope scope = AnalysisScopeReader.readJavaScope(scopeFileData, null, MiniJar.class.getClassLoader());
	//AnalysisScope scope = new Java9AnalysisScopeReader().makeJavaBinaryAnalysisScope(scopeFile, null);
	AnalysisScope scope =
				new Java9AnalysisScopeReader().readJavaScope(scopeFileData, null, MiniJar.class.getClassLoader());
	
	
	// set exclusions.  we use these exclusions as standard for handling JDK 8
	//addDefaultExclusions(scope);
	IClassHierarchy cha = ClassHierarchyFactory.make(scope);
	System.out.println(cha.getNumberOfClasses() + " classes");
	System.out.println(Warnings.asString());
	Warnings.clear();
	AnalysisOptions options = new AnalysisOptions();
	Iterable<Entrypoint> entrypoints =  Util.makeMainEntrypoints(scope, cha, mainClass);
	Set<Entrypoint> entrypointsSet = new HashSet<Entrypoint>();
	entrypoints.forEach(e -> entrypointsSet.add(e));
	System.out.println("entrypoints:" + entrypointsSet.size());
	options.setEntrypoints(entrypoints);
	// you can dial down reflection handling if you like
	options.setReflectionOptions(AnalysisOptions.ReflectionOptions.NONE);
	AnalysisCache cache = new AnalysisCacheImpl();
	// other builders can be constructed with different Util methods
	//CallGraphBuilder builder = Util.makeZeroOneContainerCFABuilder(options, cache, cha, scope);
	//CallGraphBuilder builder = Util.makeZeroCFABuilder(Language.JAVA, options, cache, cha, scope);
	CallGraphBuilder builder = Util. makeRTABuilder(options, cache, cha, scope);
	//CallGraphBuilder builder = Util.makeNCFABuilder(2, options, cache, cha, scope);
	//CallGraphBuilder builder = Util.makeVanillaNCFABuilder(2, options, cache, cha, scope);
	System.out.println("building call graph...");
	CallGraph cg = builder.makeCallGraph(options, null);
	System.out.println("done! " + cg.getNumberOfNodes());
	
	Set<String> allMethods = new HashSet<String>();
	cg.forEach(n -> allMethods.add(getMethodDescriptor(n.getMethod())));
	System.out.println("number of methods: " + allMethods.size());
	

	return allMethods;
  }
  
  private static String getMethodDescriptor(IMethod m) {
//	  IClass klass = m.getDeclaringClass();
//	  klass.
//	  m.getClassHierarchy().get
	  if (m.getName().toString().equals("area")) {
		  System.out.println("**** " + getMethodString(m.getDeclaringClass().getName().toString(), m.getName().toString(), m.getDescriptor().toString()));
	  }
	  return getMethodString(m.getDeclaringClass().getName().toString(), m.getName().toString(), m.getDescriptor().toString());
  }
  

  private static final String EXCLUSIONS = "java\\/awt\\/.*\n" + 
	  		"javax\\/swing\\/.*\n" + 
	  		"sun\\/awt\\/.*\n" + 
	  		"sun\\/swing\\/.*\n" + 
	  		"com\\/sun\\/.*\n" + 
	  		"sun\\/.*\n" + 
	  		"org\\/netbeans\\/.*\n" + 
	  		"org\\/openide\\/.*\n" + 
	  		"com\\/ibm\\/crypto\\/.*\n" + 
	  		"com\\/ibm\\/security\\/.*\n" + 
	  		"org\\/apache\\/xerces\\/.*\n" + 
	  		"java\\/security\\/.*\n" + 
	  		"jdk\\/.*\n" +
	  		"";

	  public static void addDefaultExclusions(AnalysisScope scope) throws UnsupportedEncodingException, IOException {
		    scope.setExclusions(new FileOfClasses(new ByteArrayInputStream(EXCLUSIONS.getBytes("UTF-8"))));
	  }

}